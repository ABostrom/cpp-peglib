前書き
=====

今この本を手にとっているみなさんは「ぜひプログラミング言語を作ってみたい! 」と考えている方のお一人かもしれません。でも自分で言語を作ってみるなんて敷居が高過ぎる？ 何を隠そう少し前の私も，『コンパイラ』と名の付く技術書をパラっと眺める度に，その理論の難解さに恐れを抱きました。Orz...

少し前，仕事で数十万行にも及ぶ大きなデータファイルを作成する必要がありました。エディタを使って手作業するなら軽く数ヶ月かかってしまいます。それでは大変なので，設定ファイルを定義してプログラムにデータを生成させようということになりました。数千行の設定ファイルを作れば，ものの数分で膨大なデータを生成してくれるのです。

はたして「プログラミング言語のようなもの」を作ることになりました。「さて，どう実装する？ YACCを使う？ パーサーを手書きで書く？ でも面倒で難しそう．．．」と悩みつつWebで検索していたところ，偶然[『PEG』](https://ja.wikipedia.org/wiki/Parsing_Expression_Grammar)という可愛らしい言葉が目に入りました。PEGとは「Parsing Expression Grammar」の略号です。調べてみると，難しそうなYACCより簡単に文法が定義でき，かつPEGをサポートするライブラリがパーサーを生成してくれるのです。さらに調べてみると，PEGライブラリ自体が比較的簡単に実装可能ということも発見しました！

とりあえずいろんなWebの記事を漁りながら，仕事で使っているC++用のPEGライブラリを見よう見まねで作り始めました。はい，意外とあっさり実装できました。そのあと，設定ファイルの文法をデザインし（これがとても面白い！），そのパーサーをPEGライブラリでいとも簡単に作ることができました。

これが契機となって「自分にもプログラミング言語を作ることができるかも」と思えるようになりました。文法定義とパーサーの生成がとても簡単になったので，言語作成の敷居がぐっと下がったように感じたのです。さらにこのPEGライブラリをもっと使いやすくなるよう改良を重ね，実際に簡単な言語を作ってみました。これがとても面白い！

恥ずかし話ですが，「字句解析，構文解析，構文木，意味解析，コード生成，最適化．．．」などの言語処理系の深い専門知識は今もって持ち合わせていません。PEGの[オリジナルの論文](http://bford.info/pub/lang/peg)も完璧に理解しているわけではありません。それでも言語処理系を作ることの楽しさを十分経験でき，さらにこの分野をもっと勉強したいというモチベーションを得ることもできました。

皆さんにもこの同じ喜びを味わっていただきたと思い，この文章を書いています。必要なのはテキストエディタ（当然Vimですよね？）とC++11対応のコンパイラだけです。最新のClang，GCC，Visual C++をお持ちであれば，さっそく始めましょう！
